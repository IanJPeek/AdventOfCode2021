const { input, test } = require("./input");
let { totaller, coordinator, printMap } = require("../helpers/helpers");
let splitTest = test.split("\n");
let splitInput = input.split("\n");
// console.log({splitTest})

// PSEUDO (pt.1)
// 1) separate start polymer + insertRules
// 2) insert letters into polymer accoring to rules - insertPairs() <=> (req'd no. of times/ steps)
// 3a) identify all letters to be counted (from rules arr) - identifyAllLetters() => make letterCountObj
// 3b) find frequency of letters (findLetterFrequency(), updates letterCountObj)
// 4) find max & min from values of letterCountObj, deduct

// pt. 2 
// re-implement above...
// use rules to determine new pairs ( x 2) generated by insert
// each step determines count of new pairs (needed for next insert) + updates count of individual letters

// let polymer = splitTest[0]
// let insertRules = splitTest.slice(2)
let polymer = splitInput[0];
let insertRules = splitInput.slice(2);
// console.log({insertRules})

let insertLetters = insertRules.map(rule => rule[rule.length-1])
let stepCount = 0

// investigatory function - details how many times each letter has a rule to insert it
const countInsertLetters = (ruleEnds) => {
  const countObject = {};
  const insertLetters = []

  // populate/ init countObject
  for (let letter of ruleEnds) {
    if (!insertLetters.includes(letter)){
      insertLetters.push(letter)
      countObject[`${letter}Inserts`] = 0;
    }
  }
  
  for (let letter of ruleEnds){
    countObject[`${letter}Inserts`] = countObject[`${letter}Inserts`] + 1
  }
  
  return countObject
}
let insertCount = countInsertLetters(insertLetters);
// console.log({insertCount})

// pair of functions to a) find all possible polymer letters
//                    + b) count these (in initial polymer or later polymer strings)
const identifyAllPairLetters = (rulesArr) => {
  let allLetters = []
  let lastLetter = rulesArr[rulesArr.length -1][1] // (2nd letter of final pair)

  for (let rule of rulesArr){
    if (!allLetters.includes(rule[0])){ // (if allLetters doesn't have first letter of rule, add it)
      allLetters.push(rule[0]);
    }
  }

  if(!allLetters.includes(lastLetter)){
    allLetters.push(lastLetter)
  }
return allLetters
}
let allLetters = identifyAllPairLetters(insertRules);
// console.log({allLetters})

const findLetterFrequency = (polymer, allLetters) => {
  const countObject = {};

  // populate/ init countObject 
  for(let letter of allLetters){
    countObject[`${letter}Count`] = 0
  }

  // update countObject with count for each letter
  for(let letter of polymer){
    countObject[`${letter}Count`] = countObject[`${letter}Count`] + 1
  }

return countObject
};
let letterCount = findLetterFrequency(polymer, allLetters)
// console.log({letterCount})


// function to determine new pairs formed after inserting a letter
const identifyPairsFormedByInsertRules = (rulesArr) => {

  const pairsFromRuleLookUp = { }
  for (let rule of rulesArr) {
    let key = rule.slice(0,2)
    pairsFromRuleLookUp[`${key}`] = {
      pair1 : `${rule.slice(0,1)}${rule.slice(-1)}`,
      pair2: `${rule.slice(-1)}${rule.slice(1,2)}`
    }
  }
  return pairsFromRuleLookUp;
}
const rulePairLookup = identifyPairsFormedByInsertRules(insertRules);

// create count object for pairs (set initial vaules to zero)
const initPairCount = (rulesArr) => {
  let pairCount = {}

  for (let rule of rulesArr){
    pairCount[`${rule.slice(0,2)}`] = 0
  }
  return pairCount
};
let pairCountTemplate = initPairCount(insertRules);


// v1 (pt.1) function, makes new polymer string, inserting letter according to rules
const insertPairs = () => {
  let newPolymer = "" + polymer[0]  
  
  for (let i=1; i<polymer.length; i++){ 
    // make pair (letter before index + index)
    let pairStart = polymer[i-1]
    let pairClose = polymer[i]
    let pair = `${pairStart}${pairClose}`  // add insert + current letter (2nd of pair)

    for (let rule of insertRules){
      let insertLetter
      if(rule.startsWith(pair)){ 
        insertLetter = rule[rule.length-1]
        newPolymer = newPolymer + insertLetter + pairClose
      }
    }
  }
  // console.log({ stepCount }, polymer.length);
  stepCount = stepCount + 1 
  return newPolymer;
}
// polymer = insertPairs()
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs(); // (10 steps)

// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs(); 

// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs(); 

// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs();
// polymer = insertPairs(); 
// console.log(polymer.length);

const countStartPairs = () => {

  let pairCount = {...pairCountTemplate}

  for (let i = 1; i < polymer.length; i++) {
    // make pair (letter before index + index)
    let pairStart = polymer[i - 1];
    let pairClose = polymer[i];
    let pair = `${pairStart}${pairClose}`; // add insert + current letter (2nd of pair)
    pairCount[`${pair}`] = pairCount[`${pair}`] + 1
  }
  stepCount = stepCount + 1;
  return pairCount;
};
let startCount = countStartPairs()
console.log({startCount})

// v2 (pt. 2 function), uses pairCountObj (& rulePairLookup) to a) determine no. of pairs of each type in new polymer
//                                        + b) increment individual letter count (init from initial polymer string)         
const addNewPairs = (pairCountObj) => {

  let originalPairs = { ...pairCountObj };  // copy current pairs
  let newPairs = {...pairCountTemplate}  // track updated count of pairs

  for (let pair in originalPairs) {
    let numOfPairs = originalPairs[pair];

    if (numOfPairs) {
      let { pair1, pair2 } = rulePairLookup[`${pair}`]; // determine new pairs formed from initial pair
      newPairs[`${pair1}`] = newPairs[`${pair1}`] + numOfPairs;
      newPairs[`${pair2}`] = newPairs[`${pair2}`] + numOfPairs;
      
      let insertLetter = pair2[0]  // update count of individual letters
      letterCount[`${insertLetter}Count`] =
      letterCount[`${insertLetter}Count`] + numOfPairs;
    }
  }
 

return newPairs
}
// console.log("\n",{ letterCount });
let latestPairCount = addNewPairs(startCount)
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);

latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);

latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);

latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);
latestPairCount = addNewPairs(latestPairCount);

const findMaxLessMin = (letterCountObj) => {
let countNums = Object.values(letterCountObj) // get values for letter counts
let max = Math.max(...countNums) // find max + min, subtract, rtn difference
let min = Math.min(...countNums);
let maxLessMin = max - min 
return maxLessMin
}
const pt1Ans = findMaxLessMin(letterCount)
console.log({pt1Ans}) // pt 1 ans = 2947
// pt2Ans = 3,232,426,226,464